/******************************************************************************
 * Модуль:      adc_stat.c
 * Автор:       Celeron (c) 2018 
 * Назначение:  Математическая постобработка потока данных с АЦП.
 ******************************************************************************/
 
#include <stdio.h>      // Подключить стандартные библиотеки Си
#include <stdint.h>
//#include <math.h>

#include "adc_stat.h"   // прототипы локальных функций и типов



//============================================================================
// Макроопределения и Прототипы функций
//============================================================================

// Макросы математических функций
#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
#define AVG(X, Y) (((X) + (Y))/2)
#define ABS(X)    (((X) <  0 ) ? -(X) : (X))
#define SIGN(X)   (((X) <  0 ) ? (-1) : (+1))

#ifndef NUMBER_OF_ARRAY_ITEMS
  // Стандартный вспомогательный приемчик: вычисляет количество элементов в массиве.
  // См. справку по "Препроцессору Си"... http://ru-wiki.org/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80_%D0%A1%D0%B8
  #define NUMBER_OF_ARRAY_ITEMS( array ) ( sizeof( array ) / sizeof( *(array) ) )
#endif




//============================================================================
// Усреднение выборки "скользящим окном"
//============================================================================

  
// Настройка: Размер "скользящего окна", в степенях двойки (например, 2^7 = 128 значений)
//  Рекомендуется выбирать "Размер Окна" равный:
//    = 2^3 = 8 значений, если нужно увеличить разрядность АЦП на еще один псевдоразряд;
//    = 2^7 и более, как можно больше - для лучшего сглаживания/усреднения... 
//    Но чем больше окно, тем медленнее динамика реакции на изменения входного сигнала! Поэтому нужен компромис усреднения-динамики... 
//    Так что, "Размер Окна" болше определяется скоростью семплирования АЦП... И итоговое Окно следуется расчитывать от "Максимальной Скорости Семплирования"/"Скорость изменения Входного сигнала":
//    Например: 15000 SPS * 1мс = 15 значений, т.е. ближе всего 16 значений = 2^4
#define ADC_AVG_ARRAY_COUNT_2POW   4


// Примечание: настройка степенью "7", вместо итогового числа "128", здесь, применяется для оптимизации (далее, в коде используется "сдвиг" вместо полного "деления")...
#define ADC_AVG_ARRAY_COUNT        (1 << ADC_AVG_ARRAY_COUNT_2POW)


// Проверка: Величина "окна" должна быть до 32768 элементов
#if ((ADC_AVG_ARRAY_COUNT_2POW) > 15)
#error "Ошибка: слишком большое окно! Значение ADC_AVG_ARRAY_COUNT_2POW должно быть выбрано из диапазона [1..15]"
#endif



//-------------------------------------

// "Циклический буфер" для значений "скользящего окна"
volatile int32_t ADC_AVG_MovingAverageArray[ ADC_AVG_ARRAY_COUNT ];

// Индекс последнего добавленного элемента в "циклический буфер"
volatile uint16_t ADC_AVG_LastElementIndex = 0;
  
// Счетчик предварительной Заполнености массива-буфера  (функция ADC_AVG_GetMovingAverage начинает возвращать результаты только после полного заполнения Массива после Reset)
volatile uint16_t ADC_AVG_ArrayFillingComplete = ADC_AVG_ARRAY_COUNT;


// Временная: Сумма всех элементов в массиве
volatile int32_t ADC_AVG_ArrayTotalSum = 0;

// Статистика: Исторический Максимум (за все время с последнего Сброса)
volatile int32_t ADC_AVG_HistoricalMax = INT32_MIN;

// Статистика: Исторический Минимум (за все время с последнего Сброса)
volatile int32_t ADC_AVG_HistoricalMin = INT32_MAX;



//-------------------------------------  
// Обнулить накопительный массив и переинициализировать все счётчики - начать стат.обработку заново
//  (код реентерабельный)
void ADC_AVG_ResetArray(void)
{
  // Установить признак "обнуление окна"
  //  (Замечу, что фактическое "обнуление выборки и перерасчет среднего" будет произведено уже в приоритетной функции ADC_AVG_IncludeSample...)
  ADC_AVG_ArrayFillingComplete = ADC_AVG_ARRAY_COUNT;
  
  // Примечание: в этой функции не нужно делать сброс глобальных переменных!
  //  ADC_AVG_ArrayTotalSum = 0;
  //  ADC_AVG_HistoricalMax = INT32_MIN;
  //  ADC_AVG_HistoricalMin = INT32_MAX;

  // Индекс текущего элемента, также, сбрасывать не нужно!
  //  (Поясню: не важно с какого элемента заполнять циклический массив... А чем меньше данных меняется неатомарно и асинхронно - тем меньше конфликтов в параллельном коде.)
  //ADC_AVG_LastElementIndex = 0;
  
}


//-------------------------------------  
// Добавить очередной Замер к Выборке (скользящее окно сдвигается на единицу, вытесняя самую раннюю запись)
//  (Внимание: код этой функции НЕ РЕЕНТЕРАБЕЛЬНЫЙ - запускать только из одного Потока!)
//  (Внимание: код этой функции НЕ БЛОКИРУЮЩИЙ - допустимо вызывать из Обработчика Прерывания.)
//
//  (Желательно, но уже не обязательно, т.к. код модифицирован для минимизации вероятности нарушения целостности данных: 
//  ранее, код этой функции должен был выполняться АТОМАРНО - запускаться из Потока с наивысшим приоритетом, или покрыть вызов Критической секцией! Желательно, вызывать эту функцию из Обработчика Прерывания.)
//
void ADC_AVG_IncludeSample(const int32_t value)
{
  int32_t  TotalSum;                                 //Сумма массива
  uint16_t ElementIndex;                             //Индекс последнего элемента
  uint16_t FillingComplete;                          //Счетчик предварительной заполненности Окна
  int32_t  HistoricalMax;                            //Исторический Максимум
  int32_t  HistoricalMin;                            //Исторический Минимум
  
  do
  {
    // Значения из глобальных переменных помещаются во временные ВНУТРЕННИЕ переменные  (Важно: для обеспечения атомарной коррекции значений глобальных переменных.)
    TotalSum        = ADC_AVG_ArrayTotalSum;         //Сумма массива
    ElementIndex    = ADC_AVG_LastElementIndex;      //Индекс последнего элемента
    FillingComplete = ADC_AVG_ArrayFillingComplete;  //Счетчик предварительной заполненности Окна
    HistoricalMax   = ADC_AVG_HistoricalMax;         //Исторический Максимум
    HistoricalMin   = ADC_AVG_HistoricalMin;         //Исторический Минимум
    
    
    // Фактическое обнуление окна (реализация отложенного сброса)
    if(FillingComplete == ADC_AVG_ARRAY_COUNT)
    {
      TotalSum = 0;
      
      // Сбросить статистику
      HistoricalMax = INT32_MIN;
      HistoricalMin = INT32_MAX;    
    }
    

    // Циклически перемещаем "индекс элемента" на "самый ранний из выборки"
    //ElementIndex = (ElementIndex + 1) % ADC_AVG_ARRAY_COUNT;
    ElementIndex++;
    ElementIndex %= ADC_AVG_ARRAY_COUNT;
    
    // Перерасчет Суммы массива
    if(FillingComplete == 0) 
    {
      // Если "Сумма окна" действительна, то вычесть из нее "самый ранний элемент"...
      TotalSum -= ADC_AVG_MovingAverageArray[ ElementIndex ];
    }
    else
    {
      // Уменьшаем счетчик, т.к. только что учли очередную выборку
      FillingComplete--;
    }

    //...и прибавить "новый элемент"
    TotalSum += value;
    
    // "Новый элемент" переписывает "самый ранний элемент"
    ADC_AVG_MovingAverageArray[ ElementIndex ] = value;
    
    
    // Обновить Статистику
    if(HistoricalMax < value)
      HistoricalMax = value;
    
    if(HistoricalMin > value)
      HistoricalMin = value;

    
    // Значения из временных внутренних переменных обновляют ГЛОБАЛЬНЫЕ переменные  (Важно: помещать в глобальные переменные следует уже конечные расчитанные значения, без промежуточных расчетов - обеспечиваем атомарность расчета!)
    ADC_AVG_ArrayTotalSum    = TotalSum;        //Сумма массива
    ADC_AVG_LastElementIndex = ElementIndex;    //Индекс последнего элемента
    ADC_AVG_HistoricalMax    = HistoricalMax;   //Исторический Максимум
    ADC_AVG_HistoricalMin    = HistoricalMin;   //Исторический Минимум
  }
  while((ADC_AVG_ArrayFillingComplete == ADC_AVG_ARRAY_COUNT) && (FillingComplete < (ADC_AVG_ARRAY_COUNT-1)));  
    //Проверка на АТОМАРНОСТЬ: Если во время выполнения тела функции, асинхронно был вызван ADC_AVG_ResetArray(), то тело функции перезапускается.
    //(Тогда, на повторной итерации цикла, Массив и счетчики будут обнулены - и влияние предыдущего изменения данных будет нивелировано.)
  
  ADC_AVG_ArrayFillingComplete = FillingComplete;   //Эта глобальная переменная является своеобразным Флагом атомарности.
}


//-------------------------------------  
// Вернуть текущее "среднее арифметическое по выборке", собранное методом "скользящего окна"
//  (код реентерабельный)
int32_t ADC_AVG_GetMovingAverage(void)
{
  // Примечание: хитрая реализация кода, в этой функции, обеспечивает "ленивую (неблокирующую) проверку" атомарности доступа к данным... ТАК НАДО!

  // Значения из глобальных переменных помещаются во временные ВНУТРЕННИЕ переменные
  int32_t TotalSum;
  
  if(ADC_AVG_ArrayFillingComplete == 0)
  {
    //Сумма массива
    TotalSum = ADC_AVG_ArrayTotalSum;

    // Примечание: повторная проверка, здесь, позволяет исключить "гонки" 
    //  (на случай если параллельный запуск ADC_AVG_ResetArray() перебьет ход выполнения между двумя последними инструкциями - 
    //  и сбросит счетчик ADC_AVG_ArrayFillingComplete, деактуализировав значение TotalSum...)
    if(ADC_AVG_ArrayFillingComplete == 0)
    {
      // Поскольку Массив уже заполнен, то выдаем подсчитанное СРЕДНЕЕ
      return (TotalSum >> ADC_AVG_ARRAY_COUNT_2POW);
    }
  }  

  // Массив скользящего среднего еще не заполнился полностью - пока не могу выдать правильный результат, возвращаю нейтральное значение.
  return 0;
}


//-------------------------------------  
// Вернуть максимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
//  (код реентерабельный)
extern __inline int32_t ADC_AVG_GetHistoricalMax(void)
{
  return ADC_AVG_HistoricalMax;
}


//-------------------------------------  
// Вернуть минимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
//  (код реентерабельный)
extern __inline int32_t ADC_AVG_GetHistoricalMin(void)
{
  return ADC_AVG_HistoricalMin;
}




//============================================================================
// Стат.оценка выборки
//============================================================================


// Статистика: "максимальное значение" по Текущей Выборке
volatile int32_t ADC_AVG_ArrayMax = INT32_MIN;

// Статистика: "минимальное значение" по Текущей Выборке
volatile int32_t ADC_AVG_ArrayMin = INT32_MAX;

// Статистика: "Стандартное отклонение" по Текущей Выборке
volatile int32_t ADC_AVG_ArrayStdDev = 0;



//-------------------------------------
// Вычисление квадратного корня из целочисленного числа
// Реализация: см. "Пример 7" из статьи http://www.codenet.ru/progr/alg/sqrt.php
uint32_t sqrt_int32(int32_t l)
{
    int32_t temp;
    uint32_t div, rslt = l;
    if (l <= 0)
        return 0;
    else if (l & 0xFFFF0000L)
        if (l & 0xFF000000L)
            div = 0x3FFF;
        else
            div = 0x3FF;
    else
        if (l & 0x0FF00L)
            div = 0x3F;
        else
            div = (l > 4) ? 0x7 : l;
    while (1)
    {
        temp = l / div + div;
        div = temp >> 1;
        div += temp & 1;
        if (rslt > div)
            rslt = div;
        else
        {
            if (l / rslt == rslt - 1 && l % rslt == 0)
                rslt--;
            break;
        }
    }
    return rslt;
}



//-------------------------------------
// Рассчитать статистические показатели по текущей выборке в Массиве
//  (код НЕ реентерабельный, синхронный и долгий - использовать только для тестов!)
void ADC_AVG_CalcArrayStatistics(void)
{
  // Проверка: пока массив не заполнен - никакой статистики не расчитываем...
  if(ADC_AVG_ArrayFillingComplete > 0)
    return;
     
  
  // Временные переменные
  int32_t ArrayMax    = INT32_MIN;
  int32_t ArrayMin    = INT32_MAX;
  int32_t ArrayAvg    = ADC_AVG_GetMovingAverage();
  
  uint32_t ArrayStdDev = 0;
  int32_t value;
  
  
  // Расчет статистики
  for(uint16_t i=0; i<ADC_AVG_ARRAY_COUNT; i++)
  {
    value = ADC_AVG_MovingAverageArray[i];
    
    if(ArrayMax < value)
      ArrayMax = value;
    
    if(ArrayMin > value)
      ArrayMin = value;
    
    ArrayStdDev += (ArrayAvg - value)*(ArrayAvg - value);
  }
  
  ArrayStdDev >>= ADC_AVG_ARRAY_COUNT_2POW;
  ArrayStdDev = sqrt_int32(ArrayStdDev);
  
  
  // Сохранить Статистику
  ADC_AVG_ArrayMax    = ArrayMax;
  ADC_AVG_ArrayMin    = ArrayMin;
  ADC_AVG_ArrayStdDev = ArrayStdDev;
}


//-------------------------------------
// Получить "максимальное значение" по Текущей Выборке (долгая процедура)
//  (код реентерабельный)
extern __inline int32_t ADC_AVG_GetArrayMax(void)
{
  return ADC_AVG_ArrayMax;
}


//-------------------------------------
// Получить "минимальное значение" по Текущей Выборке (долгая процедура)
extern __inline int32_t ADC_AVG_GetArrayMin(void)
//  (код реентерабельный)
{
  return ADC_AVG_ArrayMin;
}


//-------------------------------------
// Получить "Стандартное отклонение" по Текущей Выборке (долгая процедура)
//  (код реентерабельный)
extern __inline int32_t ADC_AVG_GetArrayStdDev(void)
{
  return ADC_AVG_ArrayStdDev;
}




//============================================================================
// Калибровка и Конверсия в единицы измерения прикладной величины
//============================================================================


// Коэффициент: смещение нуля (в единицах измерения: дельта кода АЦП)
volatile int32_t ADC_CNV_OffsetCorrection = 0;

// Коэффициент: масштабирования и преобразования (в единицах измерения: "кодов АЦП" на "единицу реальной величины")
volatile int32_t ADC_CNV_FullscaleCorrection = 0;



//-------------------------------------  
// Рассчитать коэффициенты калибровки (и сохранить во внутренние переменные)


// 1шаг) замкнуть Щуп на Землю - показания АЦП сунуть сюда...
extern __inline void ADC_CNV_RecalculateOffsetCoefficient (const int32_t ZeroCode)
{
  ADC_CNV_OffsetCorrection = ZeroCode;
}


// 2шаг) подать на Щуп Образцовое напряжение (например 300V) относительно Земли - замер с АЦП и соответствующий эталон в Реальных единицах, сунуть сюда.
extern __inline void ADC_CNV_RecalculateFullscaleCoefficient(const int32_t SampleCode, const int32_t SampleReal)
{
  ADC_CNV_FullscaleCorrection = (SampleCode - ADC_CNV_OffsetCorrection) / SampleReal;
}



//-------------------------------------  
// Сохранение/восстановление коэффициентов в энергонезависимой памяти


//Получить значение внутренних переменных, хранящих коэффициенты (с целью сохранения во внешней энергонезависимой памяти, например)
extern __inline void ADC_CNV_GetCalibrationCoefficient(int32_t* Offset, int32_t* Fullscale)
{
  *Offset    = ADC_CNV_OffsetCorrection;
  *Fullscale = ADC_CNV_FullscaleCorrection;
}


//Установить значения внутренних переменных, хранящих коэффициенты (с целью восстановления ранней калибровки при включении устройства, например)
extern __inline void ADC_CNV_SetCalibrationCoefficient(const int32_t Offset, const int32_t Fullscale)
{
  ADC_CNV_OffsetCorrection    = Offset;
  ADC_CNV_FullscaleCorrection = Fullscale;
}



//-------------------------------------  
// Конверсия измеренного значения: из кода АЦП в реальные единицы  (предназначена для "абсолютных величин")
//  Примечание: эта функция предназначена только для преобразования "абсолютных величин", типа замеров АЦП. 
//  Но эта функция неприменима для преобразования "дельт величин" (типа "стандартного отклонения"), поскольку применяет к величине "коррекцию абсолютной погрешности" (которая присутствует только в абсолютных величинах)!
//  (код реентерабельный)
extern __inline int32_t ADC_CNV_ConvertCode2Real(const int32_t ValueCode)
{
  return (ValueCode - ADC_CNV_OffsetCorrection) / ADC_CNV_FullscaleCorrection;
}


// Конверсия измеренного значения: из реальных единиц в код АЦП  (предназначена для "абсолютных величин")
//  Примечание: не знаю, зачем это может понадобиться?..
//  Внимание: дает результат пониженной точности! (поскольку исходное разрешение 24-битного АЦП выше)
//  (код реентерабельный)
extern __inline int32_t ADC_CNV_ConvertReal2Code(const int32_t ValueReal)
{
  return ADC_CNV_FullscaleCorrection * ValueReal + ADC_CNV_OffsetCorrection;
}



//-------------------------------------
// Конверсия измеренного значения: из кода АЦП в реальные единицы  (предназначена для "дельта величин")
//  Примечание: эта функция предназначена только для "дельта величин", поскольку применяет к ним только "коррекцию относительной погрешности". Можно применять ее также для преобразования "стандартного отклонения"...
//  (код реентерабельный)
extern __inline int32_t ADC_CNV_ConvertDeltaCode2Real(const int32_t DeltaValueCode)
{
  return DeltaValueCode / ADC_CNV_FullscaleCorrection;
}


// Конверсия измеренного значения: из реальных единиц в код АЦП  (предназначена для "дельта величин")
//  Примечание: не знаю, зачем это может понадобиться?..
//  Внимание: дает результат пониженной точности! (поскольку исходное разрешение 24-битного АЦП выше)
//  (код реентерабельный)
extern __inline int32_t ADC_CNV_ConvertDeltaReal2Code(const int32_t DeltaValueReal)
{
  return ADC_CNV_FullscaleCorrection * DeltaValueReal;
}




//============================================================================
// Служебные методы
//============================================================================


//-------------------------------------
// Инициализация модуля
//  Параметры: Offset и Fullscale - значения калибровочных коэффициентов, восстановленные из энергонезависимой памяти
void ADC_AVG_Init(const int32_t Offset, const int32_t Fullscale)
{
  ADC_AVG_ResetArray();
  ADC_CNV_SetCalibrationCoefficient(Offset, Fullscale);
}


