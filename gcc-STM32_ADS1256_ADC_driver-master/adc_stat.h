#ifndef ADC_STAT_H
#define ADC_STAT_H


//-------------------------------------
// Усреднение выборки "скользящим окном"
//-------------------------------------


// Обнулить накопительный массив и переинициализировать все счётчики - начать стат.обработку заново
void ADC_AVG_ResetArray(void);

// Добавить очередной Замер к Выборке (скользящее окно сдвигается на единицу, вытесняя самую раннюю запись)
void ADC_AVG_IncludeSample(const int32_t value);

// Вернуть текущее "среднее арифметическое по выборке", собранное методом "скользящего окна"
int32_t ADC_AVG_GetMovingAverage(void);


// Вернуть максимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
int32_t ADC_AVG_GetHistoricalMax(void);

// Вернуть минимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
int32_t ADC_AVG_GetHistoricalMin(void);




//-------------------------------------
// Стат.оценка выборки  (тем достовернее, чем больше окно)
//-------------------------------------

void    ADC_AVG_CalcArrayStatistics(void);  //Рассчитать статистические показатели по Текущей Выборке (долгая процедура)
int32_t ADC_AVG_GetArrayMax(void);          //Получить "максимальное  значение" по Текущей Выборке (расчитанное ранее)
int32_t ADC_AVG_GetArrayMin(void);          //Получить "минимальное   значение" по Текущей Выборке (расчитанное ранее)
int32_t ADC_AVG_GetArrayStdDev(void);       //Получить "Стандартное отклонение" по Текущей Выборке (расчитанное ранее)

  // Физический смысл "Стандартного отклонения": 
  //  истинное значение измеряемой величины лежит в диапазоне [AVG - 2*StdDev .. AVG + 2*StdDev], с вероятностью 95%
  //  истинное значение измеряемой величины лежит в диапазоне [AVG - 3*StdDev .. AVG + 3*StdDev], с вероятностью 99.73%




//-------------------------------------
// Калибровка и Конверсия в единицы измерения прикладной величины
//-------------------------------------


// Рассчитать коэффициенты калибровки (и сохранить во внутренние переменные)
void ADC_CNV_RecalculateOffsetCoefficient   (int32_t ZeroCode /* Real=0V */);          // 1шаг) замкнуть Щуп на Землю - показания АЦП сунуть сюда...
void ADC_CNV_RecalculateFullscaleCoefficient(int32_t SampleCode, int32_t SampleReal);  // 2шаг) подать на Щуп Образцовое напряжение (например 300V) относительно Земли - замер с АЦП и соответствующий эталон в Реальных единицах, сунуть сюда.

// Сохранение/восстановление коэффициентов в энергонезависимой памяти
void ADC_CNV_GetCalibrationCoefficient(int32_t* Offset, int32_t* Fullscale);  //Получить значение внутренних переменных, хранящих коэффициенты (с целью сохранения во внешней энергонезависимой памяти, например)
void ADC_CNV_SetCalibrationCoefficient(int32_t  Offset, int32_t  Fullscale);  //Установить значения внутренних переменных, хранящих коэффициенты (с целью восстановления ранней калибровки при включении устройства, например)

// Конверсия измеренного значения
int32_t ADC_CNV_ConvertCode2Real(int32_t ValueCode);            //из кода АЦП в реальные единицы  (предназначена для "абсолютных величин")
int32_t ADC_CNV_ConvertReal2Code(int32_t ValueReal);            //из реальных единиц в код АЦП    (предназначена для "абсолютных величин") (Внимание: дает результат пониженной точности!)

int32_t ADC_CNV_ConvertDeltaCode2Real(int32_t DeltaValueCode);  // из кода АЦП в реальные единицы (предназначена для "дельта величин")
int32_t ADC_CNV_ConvertDeltaReal2Code(int32_t DeltaValueReal);  // из реальных единиц в код АЦП   (предназначена для "дельта величин") (Внимание: дает результат пониженной точности!)




//-------------------------------------
// Служебные методы
//-------------------------------------

// Инициализация модуля (параметры: Offset и Fullscale - значения калибровочных коэффициентов, восстановленные из энергонезависимой памяти)
void ADC_AVG_Init(const int32_t Offset, const int32_t Fullscale);
  


#endif  // ADS1256_H
