/******************************************************************************
 * Модуль:      example1.c
 * Автор:       Celeron (c) 2018
 * Назначение:  Пример использования Драйвера АЦП "ADS1256" (примечание: код нерабочий - исключительно для иллюстрации)
 ******************************************************************************/


#include "stm32f1xx_hal.h"          // подключаем HAL API
#include "cmsis_os.h"               // подключаем RTOS API

#include "ads1256_defs.h"           // Псевдонимы Управляющих Регистров и Команд микросхемы ADS1256
#include "ads1256.h"                // Подключаем поддержку АЦП
#include "adc_stat.h"               // Математическая постобработка результатов АЦП



//-------------------------------------
// настройки аппаратной части
void InitADS1256(void)
{

  // Настройка регистров/режимов аппаратной микросхемы АЦП / Инициализация АЦП модуля (установка режима по-умолчанию)
  ADS1256_Init();

  // TODO: чтобы настроить АЦП на свою конфигурацию и задачу - можно изменить код стандартной процедуры инициализации ADS1256_Init(),
  // а можно (если немного перенастроить) просто запустить несколько дополнительных команд после... (API настройки описано в модуле "ads1256.h")

  // Затем, можно перенастроить АЦП в свой режим:
  ADS1256_API_SetMultiplexerSingleP(1);                                 //DEBUG: мультиплексор входных каналов (Регистр MUX)
  ADS1256_API_SetInputBufferMode( ADS1256_STATUS_BUFEN_OFF );           //DEBUG: Входной Повторитель (увеличивает импеданс до 10..80МОм, но уменьшает динамический диапазон до 0..3V) (бит BUFEN в регистре STATUS)
  ADS1256_API_SetProgrammableGainAmplifierMode( ADS1256_ADCON_PGA_1 );  //DEBUG: Настройка "Усилителя с Программируемым коэффициентом" для входного сигнала (биты PGAx регистра ADCON)
}



//-------------------------------------
// настройка "математической постобработки"
void InitMathPostprocessing(void)
{
  // Примечание: подчеркну, что всё проиходящее в этой процедуре - никак не затрагивает сам АЦП, 
  // а только инициализирует приватные переменные в модуле Драйвера, для более специализированной работы с АЦП...


  // 1) Для минимизации Шума: "математическая постобработка" в первую очередь предполагает "усреднение результатов измерения".
  // Самый простой, но эффективный алгоритм усреднения для АЦП - усреднение "скользящим окном". Размер окна настраивается директивой ADC_AVG_ARRAY_COUNT_2POW в модуле "adc_stat.c".

  // Подключить callback-функцию для запоминания/учёта очередного результата конвертации АЦП
  ADS1256_API_SetDataRegistrator( ADC_AVG_IncludeSample );

  // Сбросить выборку "скользящего окна"
  ADC_AVG_ResetArray();



  // 2) Калибровка АЦП: реализована также внутри микросхемы, компенсирует погрешность внутренних каскадов микросхемы... 
  // Но для учёта особенностей обвязки АЦП, делителей, проводов, и непосредственно Датчика - реализована ещё "Внешняя калибровка", 
  // это же математическое преобразование (линейное выражение!) также преобразует результат измерения в "реальные единицы".

  // Настройка преобразования из "дискретных единиц" в "реальные единицы измерения" физической величины
  //  Замечу: максимальная амплитуда разрешённого напряжения на входах АЦП = -5V..+5V, но вообще это зависит от Режима. Подробнее, см. Datasheet...)
  //  Например: настройка на вход от Потенциометра 0..5000m
  ADC_CNV_RecalculateOffsetCoefficient(4000);                           //DEBUG: установка нуля
  ADC_CNV_RecalculateFullscaleCoefficient(8347000, 5000);               //DEBUG: масштабирование до 5000mV

  // TODO: произведя Калибровку, впоследствии, можно сохранять/загружать из энергонезависимой памяти только пару коэффициентов:
  // void ADC_CNV_GetCalibrationCoefficient(int32_t* Offset, int32_t* Fullscale);  //Получить значение внутренних переменных, хранящих коэффициенты (с целью сохранения во внешней энергонезависимой памяти, например)
  // void ADC_CNV_SetCalibrationCoefficient(int32_t  Offset, int32_t  Fullscale);  //Установить значения внутренних переменных, хранящих коэффициенты (с целью восстановления ранней калибровки при включении устройства, например)
}



//-------------------------------------
void DoManualConversion(void)
{
  // В режиме "Одиночного запроса" требуется вручную прочитать Замер и передать его Регистратору

  // Замечу: даже если не включён режим "непрерывной конвертации" (DATAC),
  // Внутренне, АЦП всё равно производит конвертацию с заданной "частотой семплирования",
  // только результат не передаёт по Шине SPI микроконтроллеру, а просто ложит его во внутренний "регистр данных",
  // откуда микроконтроллер может его прочитать методом ADS1256_API_ReadLastData();
  value = ADS1256_API_ConvertDataOnce();


  // Если частота семплирования достаточно велика, то нет особого смысла заставлять АЦП проводить внеочередную конвертацию методом ADS1256_API_ReadLastData();
  // Однако, иногда это полезно:
  //  - Если частота семплирования мала, скажем несколько раз в секунду, а нужно словить момент - можно произвости "Синхронную конвертацию" по внешнему событию.
  //  - Если АЦП погружается с спящий режим "STANBY" (для экономии питания устройства), а потом периодически пробуждается для быстрых одиночных замеров - удобно эти замеры инициировать вручную.
  value = ADS1256_API_ReadLastData();


  // Каким бы способом ни был получен Замер - лучше его преварительно обработать:
  //  Рекомендация: усреднять "Скользящим окном" лучше сырые данные, в Коде АЦП (так выше точность). А уже потом, обработанные показатели конвертировать в Реальные единицы (если требуется).
  ADC_AVG_IncludeSample(value);

  // Чтобы получить усреднённый результат - конечно, нужно произвести не один замер, а серию замеров!
  // Более того, естественно, что "усреднение" - замедляет реакцию выходного результата на быстрое изменение информационного сигнала.
  // Поскольку: на один "выходной результат", фактически, нужно произвести количество "реальных замеров" = "размеру окна".
  // С этим нужно быть осторожным, и правильно подбирать: "размер окна"*"частота семплирования" < "максимальная частота изменения информационного сионала".

  // Замечу, что после "сброса окна" методом ADC_AVG_ResetArray - окно должно быть сперва полностью заполнено новыми данными (т.е. нужно загрузить хотя бы количество замеров, равное размеру окна).
  // Иначе, пока окно полупустое - во избежание некорректных результатов - будет возвращаться "скользящее среднее" = 0 (нейтральное значение).

  // Получить "скользящее среднее" по текущей выборке "окна"
  int32_t average = ADC_AVG_GetMovingAverage();


  // Вывод результатов:
  printf( ADC_CNV_ConvertCode2Real( value   ));  //мгновенное значение, в реальных единицах
  printf( ADC_CNV_ConvertCode2Real( average ));  //усреднённое значение, в реальных единицах
}



//-------------------------------------
void TurnON_DATAC(void)
{
  // Перед включением "потоковой конвертации" - лучше обнулить Выборку "окна"
  ADC_AVG_ResetArray();

  // Активировать режим "RDATAC: Read Data Continuous"
  //  (Замечу: в этом режиме, никакие API-функции драйвера АЦП вызывать нельзя! Сперва, нужно вызвать метод ADS1256_API_StopDataContinuousMode[Synchronous], для остановки потоковой конвертации...)
  ADS1256_API_RunDataContinuousMode();
}



void TurnOFF_DATAC(void)
{
  // Остановить режим "SDATAC: Stop Read Data Continuous" СИНХРОННО
  //  (Примечание: После выполнения этой функции, АЦП вновь станет доступным к управлению!)
  ADS1256_API_StopDataContinuousModeSynchronous();
}



void DoAutomateConversion(void)
{
  // Серия замеров в "потоковом режиме":

  //TurnON_DATAC();
  ADC_AVG_ResetArray();
  ADS1256_API_RunDataContinuousMode();

  //Выдержка по времени или по событию "пока длится контролируемый процесс"...
  delay(1000);

  //TurnOFF_DATAC();
  ADS1256_API_StopDataContinuousModeSynchronous();


  // ----
  // Замечу: в данном случае (в потоковом режиме) - "усреднение", само по себе, несёт мало информации.
  // Вдобавок, требуется ещё и статистическая оценка Результата, для тенденции изменения величины за "последнее время" (за период заполнения окна).

  // Самое ценное при потоковом измерении - это получить "границы изменение величины, с момента последнего сброса":
  int32_t max = ADC_AVG_GetHistoricalMax();
  int32_t min = ADC_AVG_GetHistoricalMin();

  // Если "границы" показывают небольшую амплитуду, то относительно достоверной является и "усреднённое значение"...
  // Получить "скользящее среднее" по последней выборке "окна":
  int32_t average = ADC_AVG_GetMovingAverage();

  // Вывод результатов:
  //printf( ADC_CNV_ConvertCode2Real( value   ));  // В этом режиме: невозможно получить "мгновенное значение"!
  printf( ADC_CNV_ConvertCode2Real( average ));  //усреднённое значение, в реальных единицах


  // ----
  // Бонусом: можно расчитать "Статистическую оценку" по последней "выборке окна" (хотя это уже больше поможет настроить само Окно, чем для исследования прикладной измеряемой величины)
  ADC_AVG_CalcArrayStatistics();                  //Рассчитать статистические показатели по Текущей Выборке (долгая процедура)
  int32_t stat_max = ADC_AVG_GetArrayMax();       //Получить "максимальное  значение" по Текущей Выборке (расчитанное ранее)
  int32_t stat_min = ADC_AVG_GetArrayMin();       //Получить "минимальное   значение" по Текущей Выборке (расчитанное ранее)
  int32_t stat_std = ADC_AVG_GetArrayStdDev();    //Получить "Стандартное отклонение" по Текущей Выборке (расчитанное ранее)

  // Вывод результатов:
  printf( ADC_CNV_ConvertCode2Real( stat_max ));  //абсолютное значение величины, в реальных единицах
  printf( ADC_CNV_ConvertCode2Real( stat_min ));
  // относительные величины (дельты) переводтся в "реальные единицы измерения" другим методом:
  printf( ADC_CNV_ConvertDeltaCode2Real( stat_max - stat_min )); //амплитуда окна, в реальных единицах
  printf( ADC_CNV_ConvertDeltaCode2Real( stat_std ));            //стандартное отклонение, в реальных единицах
}


//-------------------------------------
void main()
{
  // Сперва: Инициализация микроконтроллера и периферии...
  // ...

  // Затем: Инициализация АЦП
  InitADS1256();
  InitMathPostprocessing();


  // Одиночный замер
  DoManualConversion();

  // или Серия замеров в "потоковом режиме"
  DoAutomateConversion();

}

